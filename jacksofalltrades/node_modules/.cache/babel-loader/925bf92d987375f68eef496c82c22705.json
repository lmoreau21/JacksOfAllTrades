{"ast":null,"code":"function createError(message) {\n  var err = new Error(message);\n  err.source = \"ulid\";\n  return err;\n} // These values should NEVER change. If\n// they do, we're no longer making ulids!\n\n\nvar ENCODING = \"0123456789ABCDEFGHJKMNPQRSTVWXYZ\"; // Crockford's Base32\n\nvar ENCODING_LEN = ENCODING.length;\nvar TIME_MAX = Math.pow(2, 48) - 1;\nvar TIME_LEN = 10;\nvar RANDOM_LEN = 16;\n\nfunction replaceCharAt(str, index, char) {\n  if (index > str.length - 1) {\n    return str;\n  }\n\n  return str.substr(0, index) + char + str.substr(index + 1);\n}\n\nfunction incrementBase32(str) {\n  var done = undefined;\n  var index = str.length;\n  var char = void 0;\n  var charIndex = void 0;\n  var maxCharIndex = ENCODING_LEN - 1;\n\n  while (!done && index-- >= 0) {\n    char = str[index];\n    charIndex = ENCODING.indexOf(char);\n\n    if (charIndex === -1) {\n      throw createError(\"incorrectly encoded string\");\n    }\n\n    if (charIndex === maxCharIndex) {\n      str = replaceCharAt(str, index, ENCODING[0]);\n      continue;\n    }\n\n    done = replaceCharAt(str, index, ENCODING[charIndex + 1]);\n  }\n\n  if (typeof done === \"string\") {\n    return done;\n  }\n\n  throw createError(\"cannot increment this string\");\n}\n\nfunction randomChar(prng) {\n  var rand = Math.floor(prng() * ENCODING_LEN);\n\n  if (rand === ENCODING_LEN) {\n    rand = ENCODING_LEN - 1;\n  }\n\n  return ENCODING.charAt(rand);\n}\n\nfunction encodeTime(now, len) {\n  if (isNaN(now)) {\n    throw new Error(now + \" must be a number\");\n  }\n\n  if (now > TIME_MAX) {\n    throw createError(\"cannot encode time greater than \" + TIME_MAX);\n  }\n\n  if (now < 0) {\n    throw createError(\"time must be positive\");\n  }\n\n  if (Number.isInteger(now) === false) {\n    throw createError(\"time must be an integer\");\n  }\n\n  var mod = void 0;\n  var str = \"\";\n\n  for (; len > 0; len--) {\n    mod = now % ENCODING_LEN;\n    str = ENCODING.charAt(mod) + str;\n    now = (now - mod) / ENCODING_LEN;\n  }\n\n  return str;\n}\n\nfunction encodeRandom(len, prng) {\n  var str = \"\";\n\n  for (; len > 0; len--) {\n    str = randomChar(prng) + str;\n  }\n\n  return str;\n}\n\nfunction decodeTime(id) {\n  if (id.length !== TIME_LEN + RANDOM_LEN) {\n    throw createError(\"malformed ulid\");\n  }\n\n  var time = id.substr(0, TIME_LEN).split(\"\").reverse().reduce(function (carry, char, index) {\n    var encodingIndex = ENCODING.indexOf(char);\n\n    if (encodingIndex === -1) {\n      throw createError(\"invalid character found: \" + char);\n    }\n\n    return carry += encodingIndex * Math.pow(ENCODING_LEN, index);\n  }, 0);\n\n  if (time > TIME_MAX) {\n    throw createError(\"malformed ulid, timestamp too large\");\n  }\n\n  return time;\n}\n\nfunction detectPrng() {\n  var allowInsecure = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n  var root = arguments[1];\n\n  if (!root) {\n    root = typeof window !== \"undefined\" ? window : null;\n  }\n\n  var browserCrypto = root && (root.crypto || root.msCrypto);\n\n  if (browserCrypto) {\n    return function () {\n      var buffer = new Uint8Array(1);\n      browserCrypto.getRandomValues(buffer);\n      return buffer[0] / 0xff;\n    };\n  } else {\n    try {\n      var nodeCrypto = require(\"crypto\");\n\n      return function () {\n        return nodeCrypto.randomBytes(1).readUInt8() / 0xff;\n      };\n    } catch (e) {}\n  }\n\n  if (allowInsecure) {\n    try {\n      console.error(\"secure crypto unusable, falling back to insecure Math.random()!\");\n    } catch (e) {}\n\n    return function () {\n      return Math.random();\n    };\n  }\n\n  throw createError(\"secure crypto unusable, insecure Math.random not allowed\");\n}\n\nfunction factory(currPrng) {\n  if (!currPrng) {\n    currPrng = detectPrng();\n  }\n\n  return function ulid(seedTime) {\n    if (isNaN(seedTime)) {\n      seedTime = Date.now();\n    }\n\n    return encodeTime(seedTime, TIME_LEN) + encodeRandom(RANDOM_LEN, currPrng);\n  };\n}\n\nfunction monotonicFactory(currPrng) {\n  if (!currPrng) {\n    currPrng = detectPrng();\n  }\n\n  var lastTime = 0;\n  var lastRandom = void 0;\n  return function ulid(seedTime) {\n    if (isNaN(seedTime)) {\n      seedTime = Date.now();\n    }\n\n    if (seedTime <= lastTime) {\n      var incrementedRandom = lastRandom = incrementBase32(lastRandom);\n      return encodeTime(lastTime, TIME_LEN) + incrementedRandom;\n    }\n\n    lastTime = seedTime;\n    var newRandom = lastRandom = encodeRandom(RANDOM_LEN, currPrng);\n    return encodeTime(seedTime, TIME_LEN) + newRandom;\n  };\n}\n\nvar ulid = factory();\nexport { replaceCharAt, incrementBase32, randomChar, encodeTime, encodeRandom, decodeTime, detectPrng, factory, monotonicFactory, ulid };","map":{"version":3,"names":["createError","message","err","Error","source","ENCODING","ENCODING_LEN","length","TIME_MAX","Math","pow","TIME_LEN","RANDOM_LEN","replaceCharAt","str","index","char","substr","incrementBase32","done","undefined","charIndex","maxCharIndex","indexOf","randomChar","prng","rand","floor","charAt","encodeTime","now","len","isNaN","Number","isInteger","mod","encodeRandom","decodeTime","id","time","split","reverse","reduce","carry","encodingIndex","detectPrng","allowInsecure","arguments","root","window","browserCrypto","crypto","msCrypto","buffer","Uint8Array","getRandomValues","nodeCrypto","require","randomBytes","readUInt8","e","console","error","random","factory","currPrng","ulid","seedTime","Date","monotonicFactory","lastTime","lastRandom","incrementedRandom","newRandom"],"sources":["C:/Users/lmore/OneDrive/Documents/GitHub/JacksOfAllTrades/jacksofalltrades/node_modules/ulid/dist/index.esm.js"],"sourcesContent":["function createError(message) {\n    var err = new Error(message);\n    err.source = \"ulid\";\n    return err;\n}\n// These values should NEVER change. If\n// they do, we're no longer making ulids!\nvar ENCODING = \"0123456789ABCDEFGHJKMNPQRSTVWXYZ\"; // Crockford's Base32\nvar ENCODING_LEN = ENCODING.length;\nvar TIME_MAX = Math.pow(2, 48) - 1;\nvar TIME_LEN = 10;\nvar RANDOM_LEN = 16;\nfunction replaceCharAt(str, index, char) {\n    if (index > str.length - 1) {\n        return str;\n    }\n    return str.substr(0, index) + char + str.substr(index + 1);\n}\nfunction incrementBase32(str) {\n    var done = undefined;\n    var index = str.length;\n    var char = void 0;\n    var charIndex = void 0;\n    var maxCharIndex = ENCODING_LEN - 1;\n    while (!done && index-- >= 0) {\n        char = str[index];\n        charIndex = ENCODING.indexOf(char);\n        if (charIndex === -1) {\n            throw createError(\"incorrectly encoded string\");\n        }\n        if (charIndex === maxCharIndex) {\n            str = replaceCharAt(str, index, ENCODING[0]);\n            continue;\n        }\n        done = replaceCharAt(str, index, ENCODING[charIndex + 1]);\n    }\n    if (typeof done === \"string\") {\n        return done;\n    }\n    throw createError(\"cannot increment this string\");\n}\nfunction randomChar(prng) {\n    var rand = Math.floor(prng() * ENCODING_LEN);\n    if (rand === ENCODING_LEN) {\n        rand = ENCODING_LEN - 1;\n    }\n    return ENCODING.charAt(rand);\n}\nfunction encodeTime(now, len) {\n    if (isNaN(now)) {\n        throw new Error(now + \" must be a number\");\n    }\n    if (now > TIME_MAX) {\n        throw createError(\"cannot encode time greater than \" + TIME_MAX);\n    }\n    if (now < 0) {\n        throw createError(\"time must be positive\");\n    }\n    if (Number.isInteger(now) === false) {\n        throw createError(\"time must be an integer\");\n    }\n    var mod = void 0;\n    var str = \"\";\n    for (; len > 0; len--) {\n        mod = now % ENCODING_LEN;\n        str = ENCODING.charAt(mod) + str;\n        now = (now - mod) / ENCODING_LEN;\n    }\n    return str;\n}\nfunction encodeRandom(len, prng) {\n    var str = \"\";\n    for (; len > 0; len--) {\n        str = randomChar(prng) + str;\n    }\n    return str;\n}\nfunction decodeTime(id) {\n    if (id.length !== TIME_LEN + RANDOM_LEN) {\n        throw createError(\"malformed ulid\");\n    }\n    var time = id.substr(0, TIME_LEN).split(\"\").reverse().reduce(function (carry, char, index) {\n        var encodingIndex = ENCODING.indexOf(char);\n        if (encodingIndex === -1) {\n            throw createError(\"invalid character found: \" + char);\n        }\n        return carry += encodingIndex * Math.pow(ENCODING_LEN, index);\n    }, 0);\n    if (time > TIME_MAX) {\n        throw createError(\"malformed ulid, timestamp too large\");\n    }\n    return time;\n}\nfunction detectPrng() {\n    var allowInsecure = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n    var root = arguments[1];\n\n    if (!root) {\n        root = typeof window !== \"undefined\" ? window : null;\n    }\n    var browserCrypto = root && (root.crypto || root.msCrypto);\n    if (browserCrypto) {\n        return function () {\n            var buffer = new Uint8Array(1);\n            browserCrypto.getRandomValues(buffer);\n            return buffer[0] / 0xff;\n        };\n    } else {\n        try {\n            var nodeCrypto = require(\"crypto\");\n            return function () {\n                return nodeCrypto.randomBytes(1).readUInt8() / 0xff;\n            };\n        } catch (e) {}\n    }\n    if (allowInsecure) {\n        try {\n            console.error(\"secure crypto unusable, falling back to insecure Math.random()!\");\n        } catch (e) {}\n        return function () {\n            return Math.random();\n        };\n    }\n    throw createError(\"secure crypto unusable, insecure Math.random not allowed\");\n}\nfunction factory(currPrng) {\n    if (!currPrng) {\n        currPrng = detectPrng();\n    }\n    return function ulid(seedTime) {\n        if (isNaN(seedTime)) {\n            seedTime = Date.now();\n        }\n        return encodeTime(seedTime, TIME_LEN) + encodeRandom(RANDOM_LEN, currPrng);\n    };\n}\nfunction monotonicFactory(currPrng) {\n    if (!currPrng) {\n        currPrng = detectPrng();\n    }\n    var lastTime = 0;\n    var lastRandom = void 0;\n    return function ulid(seedTime) {\n        if (isNaN(seedTime)) {\n            seedTime = Date.now();\n        }\n        if (seedTime <= lastTime) {\n            var incrementedRandom = lastRandom = incrementBase32(lastRandom);\n            return encodeTime(lastTime, TIME_LEN) + incrementedRandom;\n        }\n        lastTime = seedTime;\n        var newRandom = lastRandom = encodeRandom(RANDOM_LEN, currPrng);\n        return encodeTime(seedTime, TIME_LEN) + newRandom;\n    };\n}\nvar ulid = factory();\n\nexport { replaceCharAt, incrementBase32, randomChar, encodeTime, encodeRandom, decodeTime, detectPrng, factory, monotonicFactory, ulid };\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}