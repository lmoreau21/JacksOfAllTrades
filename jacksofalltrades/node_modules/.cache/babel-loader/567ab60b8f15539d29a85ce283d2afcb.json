{"ast":null,"code":"var __read = this && this.__read || function (o, n) {\n  var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n  if (!m) return o;\n  var i = m.call(o),\n      r,\n      ar = [],\n      e;\n\n  try {\n    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) {\n      ar.push(r.value);\n    }\n  } catch (error) {\n    e = {\n      error: error\n    };\n  } finally {\n    try {\n      if (r && !r.done && (m = i[\"return\"])) m.call(i);\n    } finally {\n      if (e) throw e.error;\n    }\n  }\n\n  return ar;\n};\n\nvar __spread = this && this.__spread || function () {\n  for (var ar = [], i = 0; i < arguments.length; i++) {\n    ar = ar.concat(__read(arguments[i]));\n  }\n\n  return ar;\n};\n\nvar __values = this && this.__values || function (o) {\n  var s = typeof Symbol === \"function\" && Symbol.iterator,\n      m = s && o[s],\n      i = 0;\n  if (m) return m.call(o);\n  if (o && typeof o.length === \"number\") return {\n    next: function next() {\n      if (o && i >= o.length) o = void 0;\n      return {\n        value: o && o[i++],\n        done: !o\n      };\n    }\n  };\n  throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\n};\n\nvar connectionTimeout = function connectionTimeout(error) {\n  return /^Connection failed: Connection Timeout/.test(error.message);\n};\n\nvar serverError = function serverError(error) {\n  return /^Error: Request failed with status code 5\\d\\d/.test(error.message);\n};\n\nexport var mutationErrorMap = {\n  BadModel: function BadModel() {\n    return false;\n  },\n  BadRecord: function BadRecord(error) {\n    var message = error.message;\n    return /^Cannot return \\w+ for [\\w-_]+ type/.test(message) || /^Variable '.+' has coerced Null value for NonNull type/.test(message); // newly required field, out of date client\n  },\n  ConfigError: function ConfigError() {\n    return false;\n  },\n  Transient: function Transient(error) {\n    return connectionTimeout(error) || serverError(error);\n  },\n  Unauthorized: function Unauthorized(error) {\n    return /^Request failed with status code 401/.test(error.message);\n  }\n};\nexport var subscriptionErrorMap = {\n  BadModel: function BadModel() {\n    return false;\n  },\n  BadRecord: function BadRecord() {\n    return false;\n  },\n  ConfigError: function ConfigError() {\n    return false;\n  },\n  Transient: function Transient(observableError) {\n    var error = unwrapObservableError(observableError);\n    return connectionTimeout(error) || serverError(error);\n  },\n  Unauthorized: function Unauthorized(observableError) {\n    var error = unwrapObservableError(observableError);\n    return /Connection failed.+Unauthorized/.test(error.message);\n  }\n};\nexport var syncErrorMap = {\n  BadModel: function BadModel() {\n    return false;\n  },\n  BadRecord: function BadRecord(error) {\n    return /^Cannot return \\w+ for [\\w-_]+ type/.test(error.message);\n  },\n  ConfigError: function ConfigError() {\n    return false;\n  },\n  Transient: function Transient(error) {\n    return connectionTimeout(error) || serverError(error);\n  },\n  Unauthorized: function Unauthorized() {\n    return false;\n  }\n};\n/**\n * Get the first error reason of an observable.\n * Allows for error maps to be easily applied to observable errors\n *\n * @param observableError an error from ZenObservable subscribe error callback\n */\n\nfunction unwrapObservableError(observableError) {\n  var _a = observableError.error,\n      _b = __read((_a === void 0 ? {\n    errors: []\n  } : _a).errors, 1),\n      error = _b[0];\n\n  return error;\n}\n\nexport function getMutationErrorType(error) {\n  return mapErrorToType(mutationErrorMap, error);\n}\nexport function getSubscriptionErrorType(error) {\n  return mapErrorToType(subscriptionErrorMap, error);\n}\nexport function getSyncErrorType(error) {\n  return mapErrorToType(syncErrorMap, error);\n}\n/**\n * Categorizes an error with a broad error type, intended to make\n * customer error handling code simpler.\n * @param errorMap Error names and a list of patterns that indicate them (each pattern as a regex or function)\n * @param error The underying error to categorize.\n */\n\nexport function mapErrorToType(errorMap, error) {\n  var e_1, _a;\n\n  var errorTypes = __spread(Object.keys(errorMap));\n\n  try {\n    for (var errorTypes_1 = __values(errorTypes), errorTypes_1_1 = errorTypes_1.next(); !errorTypes_1_1.done; errorTypes_1_1 = errorTypes_1.next()) {\n      var errorType = errorTypes_1_1.value;\n      var matcher = errorMap[errorType];\n\n      if (matcher(error)) {\n        return errorType;\n      }\n    }\n  } catch (e_1_1) {\n    e_1 = {\n      error: e_1_1\n    };\n  } finally {\n    try {\n      if (errorTypes_1_1 && !errorTypes_1_1.done && (_a = errorTypes_1.return)) _a.call(errorTypes_1);\n    } finally {\n      if (e_1) throw e_1.error;\n    }\n  }\n\n  return 'Unknown';\n}","map":{"version":3,"mappings":"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","names":["connectionTimeout","test","error","message","serverError","mutationErrorMap","BadModel","BadRecord","ConfigError","Transient","Unauthorized","subscriptionErrorMap","unwrapObservableError","observableError","syncErrorMap","_b","getMutationErrorType","mapErrorToType","getSubscriptionErrorType","getSyncErrorType","errorMap","errorTypes","__spread","Object","keys","errorTypes_1_1","errorType","matcher"],"sources":["C:\\Users\\lmore\\OneDrive\\Documents\\GitHub\\JacksOfAllTrades\\jacksofalltrades\\node_modules\\@aws-amplify\\datastore\\src\\sync\\processors\\errorMaps.ts"],"sourcesContent":["import { ErrorType } from '../../types';\n\nexport type ErrorMap = Partial<{\n\t[key in ErrorType]: (error: Error) => boolean;\n}>;\n\nconst connectionTimeout = error =>\n\t/^Connection failed: Connection Timeout/.test(error.message);\n\nconst serverError = error =>\n\t/^Error: Request failed with status code 5\\d\\d/.test(error.message);\n\nexport const mutationErrorMap: ErrorMap = {\n\tBadModel: () => false,\n\tBadRecord: error => {\n\t\tconst { message } = error;\n\t\treturn (\n\t\t\t/^Cannot return \\w+ for [\\w-_]+ type/.test(message) ||\n\t\t\t/^Variable '.+' has coerced Null value for NonNull type/.test(message)\n\t\t); // newly required field, out of date client\n\t},\n\tConfigError: () => false,\n\tTransient: error => connectionTimeout(error) || serverError(error),\n\tUnauthorized: error =>\n\t\t/^Request failed with status code 401/.test(error.message),\n};\n\nexport const subscriptionErrorMap: ErrorMap = {\n\tBadModel: () => false,\n\tBadRecord: () => false,\n\tConfigError: () => false,\n\tTransient: observableError => {\n\t\tconst error = unwrapObservableError(observableError);\n\t\treturn connectionTimeout(error) || serverError(error);\n\t},\n\tUnauthorized: observableError => {\n\t\tconst error = unwrapObservableError(observableError);\n\t\treturn /Connection failed.+Unauthorized/.test(error.message);\n\t},\n};\n\nexport const syncErrorMap: ErrorMap = {\n\tBadModel: () => false,\n\tBadRecord: error => /^Cannot return \\w+ for [\\w-_]+ type/.test(error.message),\n\tConfigError: () => false,\n\tTransient: error => connectionTimeout(error) || serverError(error),\n\tUnauthorized: () => false,\n};\n\n/**\n * Get the first error reason of an observable.\n * Allows for error maps to be easily applied to observable errors\n *\n * @param observableError an error from ZenObservable subscribe error callback\n */\nfunction unwrapObservableError(observableError: any) {\n\tconst {\n\t\terror: { errors: [error] } = {\n\t\t\terrors: [],\n\t\t},\n\t} = observableError;\n\n\treturn error;\n}\n\nexport function getMutationErrorType(error: Error): ErrorType {\n\treturn mapErrorToType(mutationErrorMap, error);\n}\n\nexport function getSubscriptionErrorType(error: Error): ErrorType {\n\treturn mapErrorToType(subscriptionErrorMap, error);\n}\n\nexport function getSyncErrorType(error: Error): ErrorType {\n\treturn mapErrorToType(syncErrorMap, error);\n}\n\n/**\n * Categorizes an error with a broad error type, intended to make\n * customer error handling code simpler.\n * @param errorMap Error names and a list of patterns that indicate them (each pattern as a regex or function)\n * @param error The underying error to categorize.\n */\nexport function mapErrorToType(errorMap: ErrorMap, error: Error): ErrorType {\n\tconst errorTypes = [...Object.keys(errorMap)] as ErrorType[];\n\tfor (const errorType of errorTypes) {\n\t\tconst matcher = errorMap[errorType];\n\t\tif (matcher(error)) {\n\t\t\treturn errorType;\n\t\t}\n\t}\n\treturn 'Unknown';\n}\n"]},"metadata":{},"sourceType":"module"}