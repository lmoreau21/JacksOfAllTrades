{"ast":null,"code":"import { __assign, __awaiter, __generator, __read } from \"tslib\";\nimport { SignatureV4 } from \"@aws-sdk/signature-v4\";\nexport function resolveAwsAuthConfig(input) {\n  var _this = this;\n\n  var credentials = input.credentials || input.credentialDefaultProvider(input);\n  var normalizedCreds = normalizeProvider(credentials);\n  var _a = input.signingEscapePath,\n      signingEscapePath = _a === void 0 ? true : _a,\n      _b = input.systemClockOffset,\n      systemClockOffset = _b === void 0 ? input.systemClockOffset || 0 : _b,\n      sha256 = input.sha256;\n  var signer;\n\n  if (input.signer) {\n    //if signer is supplied by user, normalize it to a function returning a promise for signer.\n    signer = normalizeProvider(input.signer);\n  } else {\n    //construct a provider inferring signing from region.\n    signer = function () {\n      return normalizeProvider(input.region)().then(function (region) {\n        return __awaiter(_this, void 0, void 0, function () {\n          return __generator(this, function (_a) {\n            switch (_a.label) {\n              case 0:\n                return [4\n                /*yield*/\n                , input.regionInfoProvider(region)];\n\n              case 1:\n                return [2\n                /*return*/\n                , [_a.sent() || {}, region]];\n            }\n          });\n        });\n      }).then(function (_a) {\n        var _b = __read(_a, 2),\n            regionInfo = _b[0],\n            region = _b[1];\n\n        var signingRegion = regionInfo.signingRegion,\n            signingService = regionInfo.signingService; //update client's singing region and signing service config if they are resolved.\n        //signing region resolving order: user supplied signingRegion -> endpoints.json inferred region -> client region\n\n        input.signingRegion = input.signingRegion || signingRegion || region; //signing name resolving order:\n        //user supplied signingName -> endpoints.json inferred (credential scope -> model arnNamespace) -> model service id\n\n        input.signingName = input.signingName || signingService || input.serviceId;\n        return new SignatureV4({\n          credentials: normalizedCreds,\n          region: input.signingRegion,\n          service: input.signingName,\n          sha256: sha256,\n          uriEscapePath: signingEscapePath\n        });\n      });\n    };\n  }\n\n  return __assign(__assign({}, input), {\n    systemClockOffset: systemClockOffset,\n    signingEscapePath: signingEscapePath,\n    credentials: normalizedCreds,\n    signer: signer\n  });\n}\n\nfunction normalizeProvider(input) {\n  if (typeof input === \"object\") {\n    var promisified_1 = Promise.resolve(input);\n    return function () {\n      return promisified_1;\n    };\n  }\n\n  return input;\n}","map":{"version":3,"mappings":";AAAA,SAASA,WAAT,QAA4B,uBAA5B;AA4CA,OAAM,SAAUC,oBAAV,CAAkCC,KAAlC,EAAoF;EAA1F;;EACE,IAAMC,WAAW,GAAGD,KAAK,CAACC,WAAN,IAAqBD,KAAK,CAACE,yBAAN,CAAgCF,KAAhC,CAAzC;EACA,IAAMG,eAAe,GAAGC,iBAAiB,CAACH,WAAD,CAAzC;EACQ,SAAuFD,KAAK,kBAA5F;EAAA,qBAAiB,mBAAG,IAAH,GAAOK,EAAxB;EAAA,IAA0BC,KAA6DN,KAAK,kBAA5F;EAAA,IAA0BO,iBAAiB,mBAAGP,KAAK,CAACO,iBAAN,IAA2B,CAA9B,GAA+BD,EAA1E;EAAA,IAA4EE,MAAM,GAAKR,KAAK,OAA5F;EACR,IAAIS,MAAJ;;EACA,IAAIT,KAAK,CAACS,MAAV,EAAkB;IAChB;IACAA,MAAM,GAAGL,iBAAiB,CAACJ,KAAK,CAACS,MAAP,CAA1B;EACD,CAHD,MAGO;IACL;IACAA,MAAM,GAAG;MACP,wBAAiB,CAACT,KAAK,CAACU,MAAP,CAAjB,GACGC,IADH,CACQ,UAAOD,MAAP,EAAa;QAAA;UAAA;;;gBAAO;gBAAA;gBAAA,EAAMV,KAAK,CAACY,kBAAN,CAAyBF,MAAzB,CAAN;;;gBAAF;gBAAA;gBAAA,GAAEL,SAAD,IAA4C,EAA7C,EAAiDK,MAAjD;;WAAL;SAAA;MAAqF,CAD1G,EAEGC,IAFH,CAEQ,UAACN,EAAD,EAAqB;YAApBC;YAACO,UAAU;YAAEH,MAAM;;QAChB,iBAAa,GAAqBG,UAAU,cAA5C;QAAA,IAAeC,cAAc,GAAKD,UAAU,eAA5C,CADiB,CAEzB;QACA;;QACAb,KAAK,CAACe,aAAN,GAAsBf,KAAK,CAACe,aAAN,IAAuBA,aAAvB,IAAwCL,MAA9D,CAJyB,CAKzB;QACA;;QACAV,KAAK,CAACgB,WAAN,GAAoBhB,KAAK,CAACgB,WAAN,IAAqBF,cAArB,IAAuCd,KAAK,CAACiB,SAAjE;QAEA,OAAO,IAAInB,WAAJ,CAAgB;UACrBG,WAAW,EAAEE,eADQ;UAErBO,MAAM,EAAEV,KAAK,CAACe,aAFO;UAGrBG,OAAO,EAAElB,KAAK,CAACgB,WAHM;UAIrBR,MAAM,QAJe;UAKrBW,aAAa,EAAEC;QALM,CAAhB,CAAP;MAOD,CAlBH;IAkBI,CAnBN;EAoBD;;EAED,6BACKpB,KADL,GACU;IACRO,iBAAiB,mBADT;IAERa,iBAAiB,mBAFT;IAGRnB,WAAW,EAAEE,eAHL;IAIRM,MAAM;EAJE,CADV;AAOD;;AAED,SAASL,iBAAT,CAA8BJ,KAA9B,EAAoD;EAClD,IAAI,OAAOA,KAAP,KAAiB,QAArB,EAA+B;IAC7B,IAAMqB,aAAW,GAAGC,OAAO,CAACC,OAAR,CAAgBvB,KAAhB,CAApB;IACA,OAAO;MAAM;IAAW,CAAxB;EACD;;EACD,OAAOA,KAAP;AACD","names":["SignatureV4","resolveAwsAuthConfig","input","credentials","credentialDefaultProvider","normalizedCreds","normalizeProvider","_a","_b","systemClockOffset","sha256","signer","region","then","regionInfoProvider","regionInfo","signingService","signingRegion","signingName","serviceId","service","uriEscapePath","signingEscapePath","promisified_1","Promise","resolve"],"sources":["C:\\Users\\lmore\\OneDrive\\Documents\\GitHub\\JacksOfAllTrades\\jacksofalltrades\\node_modules\\@aws-sdk\\middleware-signing\\src\\configurations.ts"],"sourcesContent":["import { SignatureV4 } from \"@aws-sdk/signature-v4\";\nimport { Credentials, HashConstructor, Provider, RegionInfo, RegionInfoProvider, RequestSigner } from \"@aws-sdk/types\";\n\nexport interface AwsAuthInputConfig {\n  /**\n   * The credentials used to sign requests.\n   */\n  credentials?: Credentials | Provider<Credentials>;\n\n  /**\n   * The signer to use when signing requests.\n   */\n  signer?: RequestSigner | Provider<RequestSigner>;\n\n  /**\n   * Whether to escape request path when signing the request.\n   */\n  signingEscapePath?: boolean;\n\n  /**\n   * An offset value in milliseconds to apply to all signing times.\n   */\n  systemClockOffset?: number;\n\n  /**\n   * The region where you want to sign your request against. This\n   * can be different to the region in the endpoint.\n   */\n  signingRegion?: string;\n}\ninterface PreviouslyResolved {\n  credentialDefaultProvider: (input: any) => Provider<Credentials>;\n  region: string | Provider<string>;\n  regionInfoProvider: RegionInfoProvider;\n  signingName?: string;\n  serviceId: string;\n  sha256: HashConstructor;\n}\nexport interface AwsAuthResolvedConfig {\n  credentials: Provider<Credentials>;\n  signer: Provider<RequestSigner>;\n  signingEscapePath: boolean;\n  systemClockOffset: number;\n}\nexport function resolveAwsAuthConfig<T>(input: T & AwsAuthInputConfig & PreviouslyResolved): T & AwsAuthResolvedConfig {\n  const credentials = input.credentials || input.credentialDefaultProvider(input as any);\n  const normalizedCreds = normalizeProvider(credentials);\n  const { signingEscapePath = true, systemClockOffset = input.systemClockOffset || 0, sha256 } = input;\n  let signer: Provider<RequestSigner>;\n  if (input.signer) {\n    //if signer is supplied by user, normalize it to a function returning a promise for signer.\n    signer = normalizeProvider(input.signer);\n  } else {\n    //construct a provider inferring signing from region.\n    signer = () =>\n      normalizeProvider(input.region)()\n        .then(async (region) => [(await input.regionInfoProvider(region)) || {}, region] as [RegionInfo, string])\n        .then(([regionInfo, region]) => {\n          const { signingRegion, signingService } = regionInfo;\n          //update client's singing region and signing service config if they are resolved.\n          //signing region resolving order: user supplied signingRegion -> endpoints.json inferred region -> client region\n          input.signingRegion = input.signingRegion || signingRegion || region;\n          //signing name resolving order:\n          //user supplied signingName -> endpoints.json inferred (credential scope -> model arnNamespace) -> model service id\n          input.signingName = input.signingName || signingService || input.serviceId;\n\n          return new SignatureV4({\n            credentials: normalizedCreds,\n            region: input.signingRegion,\n            service: input.signingName,\n            sha256,\n            uriEscapePath: signingEscapePath,\n          });\n        });\n  }\n\n  return {\n    ...input,\n    systemClockOffset,\n    signingEscapePath,\n    credentials: normalizedCreds,\n    signer,\n  };\n}\n\nfunction normalizeProvider<T>(input: T | Provider<T>): Provider<T> {\n  if (typeof input === \"object\") {\n    const promisified = Promise.resolve(input);\n    return () => promisified;\n  }\n  return input as Provider<T>;\n}\n"]},"metadata":{},"sourceType":"module"}