{"ast":null,"code":"import { __values } from \"tslib\";\nimport { fromHex, toHex } from \"@aws-sdk/util-hex-encoding\";\nimport { Int64 } from \"./Int64\";\n/**\n * @internal\n */\n\nvar HeaderMarshaller =\n/** @class */\nfunction () {\n  function HeaderMarshaller(toUtf8, fromUtf8) {\n    this.toUtf8 = toUtf8;\n    this.fromUtf8 = fromUtf8;\n  }\n\n  HeaderMarshaller.prototype.format = function (headers) {\n    var e_1, _a, e_2, _b;\n\n    var chunks = [];\n\n    try {\n      for (var _c = __values(Object.keys(headers)), _d = _c.next(); !_d.done; _d = _c.next()) {\n        var headerName = _d.value;\n        var bytes = this.fromUtf8(headerName);\n        chunks.push(Uint8Array.from([bytes.byteLength]), bytes, this.formatHeaderValue(headers[headerName]));\n      }\n    } catch (e_1_1) {\n      e_1 = {\n        error: e_1_1\n      };\n    } finally {\n      try {\n        if (_d && !_d.done && (_a = _c.return)) _a.call(_c);\n      } finally {\n        if (e_1) throw e_1.error;\n      }\n    }\n\n    var out = new Uint8Array(chunks.reduce(function (carry, bytes) {\n      return carry + bytes.byteLength;\n    }, 0));\n    var position = 0;\n\n    try {\n      for (var chunks_1 = __values(chunks), chunks_1_1 = chunks_1.next(); !chunks_1_1.done; chunks_1_1 = chunks_1.next()) {\n        var chunk = chunks_1_1.value;\n        out.set(chunk, position);\n        position += chunk.byteLength;\n      }\n    } catch (e_2_1) {\n      e_2 = {\n        error: e_2_1\n      };\n    } finally {\n      try {\n        if (chunks_1_1 && !chunks_1_1.done && (_b = chunks_1.return)) _b.call(chunks_1);\n      } finally {\n        if (e_2) throw e_2.error;\n      }\n    }\n\n    return out;\n  };\n\n  HeaderMarshaller.prototype.formatHeaderValue = function (header) {\n    switch (header.type) {\n      case \"boolean\":\n        return Uint8Array.from([header.value ? 0\n        /* boolTrue */\n        : 1\n        /* boolFalse */\n        ]);\n\n      case \"byte\":\n        return Uint8Array.from([2\n        /* byte */\n        , header.value]);\n\n      case \"short\":\n        var shortView = new DataView(new ArrayBuffer(3));\n        shortView.setUint8(0, 3\n        /* short */\n        );\n        shortView.setInt16(1, header.value, false);\n        return new Uint8Array(shortView.buffer);\n\n      case \"integer\":\n        var intView = new DataView(new ArrayBuffer(5));\n        intView.setUint8(0, 4\n        /* integer */\n        );\n        intView.setInt32(1, header.value, false);\n        return new Uint8Array(intView.buffer);\n\n      case \"long\":\n        var longBytes = new Uint8Array(9);\n        longBytes[0] = 5\n        /* long */\n        ;\n        longBytes.set(header.value.bytes, 1);\n        return longBytes;\n\n      case \"binary\":\n        var binView = new DataView(new ArrayBuffer(3 + header.value.byteLength));\n        binView.setUint8(0, 6\n        /* byteArray */\n        );\n        binView.setUint16(1, header.value.byteLength, false);\n        var binBytes = new Uint8Array(binView.buffer);\n        binBytes.set(header.value, 3);\n        return binBytes;\n\n      case \"string\":\n        var utf8Bytes = this.fromUtf8(header.value);\n        var strView = new DataView(new ArrayBuffer(3 + utf8Bytes.byteLength));\n        strView.setUint8(0, 7\n        /* string */\n        );\n        strView.setUint16(1, utf8Bytes.byteLength, false);\n        var strBytes = new Uint8Array(strView.buffer);\n        strBytes.set(utf8Bytes, 3);\n        return strBytes;\n\n      case \"timestamp\":\n        var tsBytes = new Uint8Array(9);\n        tsBytes[0] = 8\n        /* timestamp */\n        ;\n        tsBytes.set(Int64.fromNumber(header.value.valueOf()).bytes, 1);\n        return tsBytes;\n\n      case \"uuid\":\n        if (!UUID_PATTERN.test(header.value)) {\n          throw new Error(\"Invalid UUID received: \" + header.value);\n        }\n\n        var uuidBytes = new Uint8Array(17);\n        uuidBytes[0] = 9\n        /* uuid */\n        ;\n        uuidBytes.set(fromHex(header.value.replace(/\\-/g, \"\")), 1);\n        return uuidBytes;\n    }\n  };\n\n  HeaderMarshaller.prototype.parse = function (headers) {\n    var out = {};\n    var position = 0;\n\n    while (position < headers.byteLength) {\n      var nameLength = headers.getUint8(position++);\n      var name = this.toUtf8(new Uint8Array(headers.buffer, headers.byteOffset + position, nameLength));\n      position += nameLength;\n\n      switch (headers.getUint8(position++)) {\n        case 0\n        /* boolTrue */\n        :\n          out[name] = {\n            type: BOOLEAN_TAG,\n            value: true\n          };\n          break;\n\n        case 1\n        /* boolFalse */\n        :\n          out[name] = {\n            type: BOOLEAN_TAG,\n            value: false\n          };\n          break;\n\n        case 2\n        /* byte */\n        :\n          out[name] = {\n            type: BYTE_TAG,\n            value: headers.getInt8(position++)\n          };\n          break;\n\n        case 3\n        /* short */\n        :\n          out[name] = {\n            type: SHORT_TAG,\n            value: headers.getInt16(position, false)\n          };\n          position += 2;\n          break;\n\n        case 4\n        /* integer */\n        :\n          out[name] = {\n            type: INT_TAG,\n            value: headers.getInt32(position, false)\n          };\n          position += 4;\n          break;\n\n        case 5\n        /* long */\n        :\n          out[name] = {\n            type: LONG_TAG,\n            value: new Int64(new Uint8Array(headers.buffer, headers.byteOffset + position, 8))\n          };\n          position += 8;\n          break;\n\n        case 6\n        /* byteArray */\n        :\n          var binaryLength = headers.getUint16(position, false);\n          position += 2;\n          out[name] = {\n            type: BINARY_TAG,\n            value: new Uint8Array(headers.buffer, headers.byteOffset + position, binaryLength)\n          };\n          position += binaryLength;\n          break;\n\n        case 7\n        /* string */\n        :\n          var stringLength = headers.getUint16(position, false);\n          position += 2;\n          out[name] = {\n            type: STRING_TAG,\n            value: this.toUtf8(new Uint8Array(headers.buffer, headers.byteOffset + position, stringLength))\n          };\n          position += stringLength;\n          break;\n\n        case 8\n        /* timestamp */\n        :\n          out[name] = {\n            type: TIMESTAMP_TAG,\n            value: new Date(new Int64(new Uint8Array(headers.buffer, headers.byteOffset + position, 8)).valueOf())\n          };\n          position += 8;\n          break;\n\n        case 9\n        /* uuid */\n        :\n          var uuidBytes = new Uint8Array(headers.buffer, headers.byteOffset + position, 16);\n          position += 16;\n          out[name] = {\n            type: UUID_TAG,\n            value: toHex(uuidBytes.subarray(0, 4)) + \"-\" + toHex(uuidBytes.subarray(4, 6)) + \"-\" + toHex(uuidBytes.subarray(6, 8)) + \"-\" + toHex(uuidBytes.subarray(8, 10)) + \"-\" + toHex(uuidBytes.subarray(10))\n          };\n          break;\n\n        default:\n          throw new Error(\"Unrecognized header type tag\");\n      }\n    }\n\n    return out;\n  };\n\n  return HeaderMarshaller;\n}();\n\nexport { HeaderMarshaller };\nvar HEADER_VALUE_TYPE;\n\n(function (HEADER_VALUE_TYPE) {\n  HEADER_VALUE_TYPE[HEADER_VALUE_TYPE[\"boolTrue\"] = 0] = \"boolTrue\";\n  HEADER_VALUE_TYPE[HEADER_VALUE_TYPE[\"boolFalse\"] = 1] = \"boolFalse\";\n  HEADER_VALUE_TYPE[HEADER_VALUE_TYPE[\"byte\"] = 2] = \"byte\";\n  HEADER_VALUE_TYPE[HEADER_VALUE_TYPE[\"short\"] = 3] = \"short\";\n  HEADER_VALUE_TYPE[HEADER_VALUE_TYPE[\"integer\"] = 4] = \"integer\";\n  HEADER_VALUE_TYPE[HEADER_VALUE_TYPE[\"long\"] = 5] = \"long\";\n  HEADER_VALUE_TYPE[HEADER_VALUE_TYPE[\"byteArray\"] = 6] = \"byteArray\";\n  HEADER_VALUE_TYPE[HEADER_VALUE_TYPE[\"string\"] = 7] = \"string\";\n  HEADER_VALUE_TYPE[HEADER_VALUE_TYPE[\"timestamp\"] = 8] = \"timestamp\";\n  HEADER_VALUE_TYPE[HEADER_VALUE_TYPE[\"uuid\"] = 9] = \"uuid\";\n})(HEADER_VALUE_TYPE || (HEADER_VALUE_TYPE = {}));\n\nvar BOOLEAN_TAG = \"boolean\";\nvar BYTE_TAG = \"byte\";\nvar SHORT_TAG = \"short\";\nvar INT_TAG = \"integer\";\nvar LONG_TAG = \"long\";\nvar BINARY_TAG = \"binary\";\nvar STRING_TAG = \"string\";\nvar TIMESTAMP_TAG = \"timestamp\";\nvar UUID_TAG = \"uuid\";\nvar UUID_PATTERN = /^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$/;","map":{"version":3,"mappings":"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","names":["fromHex","toHex","Int64","toUtf8","fromUtf8","HeaderMarshaller","headers","chunks","keys","_d","headerName","bytes","push","Uint8Array","from","byteLength","formatHeaderValue","out","reduce","carry","position","chunks_1_1","chunk","set","header","type","value","shortView","DataView","ArrayBuffer","setUint8","setInt16","buffer","intView","setInt32","longBytes","binView","setUint16","binBytes","utf8Bytes","strView","strBytes","tsBytes","fromNumber","valueOf","UUID_PATTERN","test","Error","uuidBytes","replace","nameLength","getUint8","name","byteOffset","BOOLEAN_TAG","BYTE_TAG","getInt8","SHORT_TAG","getInt16","INT_TAG","getInt32","LONG_TAG","binaryLength","getUint16","BINARY_TAG","stringLength","STRING_TAG","TIMESTAMP_TAG","Date","UUID_TAG","subarray","HEADER_VALUE_TYPE"],"sources":["C:\\Users\\lmore\\OneDrive\\Documents\\GitHub\\JacksOfAllTrades\\jacksofalltrades\\node_modules\\@aws-sdk\\eventstream-marshaller\\src\\HeaderMarshaller.ts"],"sourcesContent":["import { Decoder, Encoder, MessageHeaders, MessageHeaderValue } from \"@aws-sdk/types\";\nimport { fromHex, toHex } from \"@aws-sdk/util-hex-encoding\";\n\nimport { Int64 } from \"./Int64\";\n\n/**\n * @internal\n */\nexport class HeaderMarshaller {\n  constructor(private readonly toUtf8: Encoder, private readonly fromUtf8: Decoder) {}\n\n  format(headers: MessageHeaders): Uint8Array {\n    const chunks: Array<Uint8Array> = [];\n\n    for (const headerName of Object.keys(headers)) {\n      const bytes = this.fromUtf8(headerName);\n      chunks.push(Uint8Array.from([bytes.byteLength]), bytes, this.formatHeaderValue(headers[headerName]));\n    }\n\n    const out = new Uint8Array(chunks.reduce((carry, bytes) => carry + bytes.byteLength, 0));\n    let position = 0;\n    for (const chunk of chunks) {\n      out.set(chunk, position);\n      position += chunk.byteLength;\n    }\n\n    return out;\n  }\n\n  private formatHeaderValue(header: MessageHeaderValue): Uint8Array {\n    switch (header.type) {\n      case \"boolean\":\n        return Uint8Array.from([header.value ? HEADER_VALUE_TYPE.boolTrue : HEADER_VALUE_TYPE.boolFalse]);\n      case \"byte\":\n        return Uint8Array.from([HEADER_VALUE_TYPE.byte, header.value]);\n      case \"short\":\n        const shortView = new DataView(new ArrayBuffer(3));\n        shortView.setUint8(0, HEADER_VALUE_TYPE.short);\n        shortView.setInt16(1, header.value, false);\n        return new Uint8Array(shortView.buffer);\n      case \"integer\":\n        const intView = new DataView(new ArrayBuffer(5));\n        intView.setUint8(0, HEADER_VALUE_TYPE.integer);\n        intView.setInt32(1, header.value, false);\n        return new Uint8Array(intView.buffer);\n      case \"long\":\n        const longBytes = new Uint8Array(9);\n        longBytes[0] = HEADER_VALUE_TYPE.long;\n        longBytes.set(header.value.bytes, 1);\n        return longBytes;\n      case \"binary\":\n        const binView = new DataView(new ArrayBuffer(3 + header.value.byteLength));\n        binView.setUint8(0, HEADER_VALUE_TYPE.byteArray);\n        binView.setUint16(1, header.value.byteLength, false);\n        const binBytes = new Uint8Array(binView.buffer);\n        binBytes.set(header.value, 3);\n        return binBytes;\n      case \"string\":\n        const utf8Bytes = this.fromUtf8(header.value);\n        const strView = new DataView(new ArrayBuffer(3 + utf8Bytes.byteLength));\n        strView.setUint8(0, HEADER_VALUE_TYPE.string);\n        strView.setUint16(1, utf8Bytes.byteLength, false);\n        const strBytes = new Uint8Array(strView.buffer);\n        strBytes.set(utf8Bytes, 3);\n        return strBytes;\n      case \"timestamp\":\n        const tsBytes = new Uint8Array(9);\n        tsBytes[0] = HEADER_VALUE_TYPE.timestamp;\n        tsBytes.set(Int64.fromNumber(header.value.valueOf()).bytes, 1);\n        return tsBytes;\n      case \"uuid\":\n        if (!UUID_PATTERN.test(header.value)) {\n          throw new Error(`Invalid UUID received: ${header.value}`);\n        }\n\n        const uuidBytes = new Uint8Array(17);\n        uuidBytes[0] = HEADER_VALUE_TYPE.uuid;\n        uuidBytes.set(fromHex(header.value.replace(/\\-/g, \"\")), 1);\n        return uuidBytes;\n    }\n  }\n\n  parse(headers: DataView): MessageHeaders {\n    const out: MessageHeaders = {};\n    let position = 0;\n\n    while (position < headers.byteLength) {\n      const nameLength = headers.getUint8(position++);\n      const name = this.toUtf8(new Uint8Array(headers.buffer, headers.byteOffset + position, nameLength));\n      position += nameLength;\n\n      switch (headers.getUint8(position++)) {\n        case HEADER_VALUE_TYPE.boolTrue:\n          out[name] = {\n            type: BOOLEAN_TAG,\n            value: true,\n          };\n          break;\n        case HEADER_VALUE_TYPE.boolFalse:\n          out[name] = {\n            type: BOOLEAN_TAG,\n            value: false,\n          };\n          break;\n        case HEADER_VALUE_TYPE.byte:\n          out[name] = {\n            type: BYTE_TAG,\n            value: headers.getInt8(position++),\n          };\n          break;\n        case HEADER_VALUE_TYPE.short:\n          out[name] = {\n            type: SHORT_TAG,\n            value: headers.getInt16(position, false),\n          };\n          position += 2;\n          break;\n        case HEADER_VALUE_TYPE.integer:\n          out[name] = {\n            type: INT_TAG,\n            value: headers.getInt32(position, false),\n          };\n          position += 4;\n          break;\n        case HEADER_VALUE_TYPE.long:\n          out[name] = {\n            type: LONG_TAG,\n            value: new Int64(new Uint8Array(headers.buffer, headers.byteOffset + position, 8)),\n          };\n          position += 8;\n          break;\n        case HEADER_VALUE_TYPE.byteArray:\n          const binaryLength = headers.getUint16(position, false);\n          position += 2;\n          out[name] = {\n            type: BINARY_TAG,\n            value: new Uint8Array(headers.buffer, headers.byteOffset + position, binaryLength),\n          };\n          position += binaryLength;\n          break;\n        case HEADER_VALUE_TYPE.string:\n          const stringLength = headers.getUint16(position, false);\n          position += 2;\n          out[name] = {\n            type: STRING_TAG,\n            value: this.toUtf8(new Uint8Array(headers.buffer, headers.byteOffset + position, stringLength)),\n          };\n          position += stringLength;\n          break;\n        case HEADER_VALUE_TYPE.timestamp:\n          out[name] = {\n            type: TIMESTAMP_TAG,\n            value: new Date(new Int64(new Uint8Array(headers.buffer, headers.byteOffset + position, 8)).valueOf()),\n          };\n          position += 8;\n          break;\n        case HEADER_VALUE_TYPE.uuid:\n          const uuidBytes = new Uint8Array(headers.buffer, headers.byteOffset + position, 16);\n          position += 16;\n          out[name] = {\n            type: UUID_TAG,\n            value: `${toHex(uuidBytes.subarray(0, 4))}-${toHex(uuidBytes.subarray(4, 6))}-${toHex(\n              uuidBytes.subarray(6, 8)\n            )}-${toHex(uuidBytes.subarray(8, 10))}-${toHex(uuidBytes.subarray(10))}`,\n          };\n          break;\n        default:\n          throw new Error(`Unrecognized header type tag`);\n      }\n    }\n\n    return out;\n  }\n}\n\nconst enum HEADER_VALUE_TYPE {\n  boolTrue = 0,\n  boolFalse,\n  byte,\n  short,\n  integer,\n  long,\n  byteArray,\n  string,\n  timestamp,\n  uuid,\n}\n\nconst BOOLEAN_TAG = \"boolean\";\nconst BYTE_TAG = \"byte\";\nconst SHORT_TAG = \"short\";\nconst INT_TAG = \"integer\";\nconst LONG_TAG = \"long\";\nconst BINARY_TAG = \"binary\";\nconst STRING_TAG = \"string\";\nconst TIMESTAMP_TAG = \"timestamp\";\nconst UUID_TAG = \"uuid\";\n\nconst UUID_PATTERN = /^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$/;\n"]},"metadata":{},"sourceType":"module"}