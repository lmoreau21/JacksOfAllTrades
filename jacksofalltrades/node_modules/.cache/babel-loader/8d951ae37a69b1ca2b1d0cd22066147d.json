{"ast":null,"code":"import along from \"@turf/along\";\nimport circle from \"@turf/circle\";\nimport length from \"@turf/length\";\nimport { lineString } from \"@turf/helpers\";\nimport { isGeofenceArray, validateCoordinates } from \"./utils\";\nconst GEOFENCE_ID_REGEX = /^[-._\\p{L}\\p{N}]+$/iu;\nexport const getGeofenceFeatureArray = data => {\n  const coordinates = isGeofenceArray(data) ? data.map(geofence => geofence.geometry.polygon) : data;\n  return {\n    type: \"Feature\",\n    geometry: {\n      type: \"MultiPolygon\",\n      coordinates\n    },\n    properties: {}\n  };\n};\nexport const getGeofenceFeatureFromPolygon = polygon => {\n  return {\n    type: \"Feature\",\n    geometry: {\n      type: \"Polygon\",\n      coordinates: polygon\n    },\n    properties: {}\n  };\n}; // Measures distance between the coordinate bounds and takes two points 1/4 from each coordinate to create a polygon\n\nexport const getPolygonFeatureFromBounds = (id, bounds) => {\n  const swCoordinate = bounds.getSouthWest().toArray();\n  const neCoordinate = bounds.getNorthEast().toArray();\n  const center = bounds.getCenter().toArray();\n  const line = lineString([swCoordinate, center, neCoordinate]);\n  const distanceInMiles = length(line, {\n    units: \"miles\"\n  }); // Gets coordinates 1/4 along the line from each coordinate\n\n  const southWestCoordinate = along(line, distanceInMiles / 4, {\n    units: \"miles\"\n  }).geometry.coordinates;\n  const northeastCoordinate = along(line, distanceInMiles * (3 / 4), {\n    units: \"miles\"\n  }).geometry.coordinates; // Creates a polygon from the coordinates found along the line between the bounding coordinates in counter clockwise order starting from northeast most coordinate\n\n  const polygon = [[northeastCoordinate, [southWestCoordinate[0], northeastCoordinate[1]], southWestCoordinate, [northeastCoordinate[0], southWestCoordinate[1]], northeastCoordinate]];\n  return {\n    id,\n    type: \"Feature\",\n    geometry: {\n      type: \"Polygon\",\n      coordinates: polygon\n    },\n    properties: {}\n  };\n};\nexport const getCircleFeatureFromCoords = (id, center, _ref) => {\n  let {\n    bounds,\n    radius\n  } = _ref;\n\n  if (!bounds && !radius) {\n    throw new Error(\"Circle requires a bounds or a radius\");\n  }\n\n  validateCoordinates(center);\n  const circleRadius = radius !== null && radius !== void 0 ? radius : getDistanceFromBounds(bounds) / 8;\n  const circleFeature = circle(center, circleRadius, {\n    units: \"miles\"\n  });\n  return {\n    id,\n    type: \"Feature\",\n    properties: {\n      isCircle: true,\n      center,\n      radius: circleRadius\n    },\n    geometry: {\n      type: \"Polygon\",\n      coordinates: circleFeature.geometry.coordinates\n    }\n  };\n};\n\nconst getDistanceFromBounds = bounds => {\n  const swCoordinate = bounds.getSouthWest().toArray();\n  const neCoordinate = bounds.getNorthEast().toArray();\n  const center = bounds.getCenter().toArray();\n  const line = lineString([swCoordinate, center, neCoordinate]);\n  return length(line, {\n    units: \"miles\"\n  });\n};\n\nexport const doesGeofenceExist = (id, loadedGeofences) => {\n  return !!loadedGeofences[id];\n};\nexport const isValidGeofenceId = id => {\n  return !!id.match(GEOFENCE_ID_REGEX);\n};\nexport const isExistingGeofenceId = (id, loadedGeofences) => {\n  return doesGeofenceExist(id, loadedGeofences);\n};\nexport const isGeofenceDisplayed = (id, displayedGeofences) => {\n  return !!displayedGeofences.find(geofence => geofence.geofenceId === id);\n};\nexport const getDistanceBetweenCoordinates = (startCoord, endCoord) => {\n  const line = lineString([startCoord, endCoord]);\n  const distanceInMiles = length(line, {\n    units: \"miles\"\n  });\n  return distanceInMiles;\n};","map":{"version":3,"names":["along","circle","length","lineString","isGeofenceArray","validateCoordinates","GEOFENCE_ID_REGEX","getGeofenceFeatureArray","data","coordinates","map","geofence","geometry","polygon","type","properties","getGeofenceFeatureFromPolygon","getPolygonFeatureFromBounds","id","bounds","swCoordinate","getSouthWest","toArray","neCoordinate","getNorthEast","center","getCenter","line","distanceInMiles","units","southWestCoordinate","northeastCoordinate","getCircleFeatureFromCoords","radius","Error","circleRadius","getDistanceFromBounds","circleFeature","isCircle","doesGeofenceExist","loadedGeofences","isValidGeofenceId","match","isExistingGeofenceId","isGeofenceDisplayed","displayedGeofences","find","geofenceId","getDistanceBetweenCoordinates","startCoord","endCoord"],"sources":["C:/Users/lmore/OneDrive/Documents/GitHub/JacksOfAllTrades/jacksofalltrades/node_modules/maplibre-gl-js-amplify/lib/esm/geofenceUtils.js"],"sourcesContent":["import along from \"@turf/along\";\nimport circle from \"@turf/circle\";\nimport length from \"@turf/length\";\nimport { lineString } from \"@turf/helpers\";\nimport { isGeofenceArray, validateCoordinates } from \"./utils\";\nconst GEOFENCE_ID_REGEX = /^[-._\\p{L}\\p{N}]+$/iu;\nexport const getGeofenceFeatureArray = (data) => {\n    const coordinates = isGeofenceArray(data)\n        ? data.map((geofence) => geofence.geometry.polygon)\n        : data;\n    return {\n        type: \"Feature\",\n        geometry: {\n            type: \"MultiPolygon\",\n            coordinates,\n        },\n        properties: {},\n    };\n};\nexport const getGeofenceFeatureFromPolygon = (polygon) => {\n    return {\n        type: \"Feature\",\n        geometry: {\n            type: \"Polygon\",\n            coordinates: polygon,\n        },\n        properties: {},\n    };\n};\n// Measures distance between the coordinate bounds and takes two points 1/4 from each coordinate to create a polygon\nexport const getPolygonFeatureFromBounds = (id, bounds) => {\n    const swCoordinate = bounds.getSouthWest().toArray();\n    const neCoordinate = bounds.getNorthEast().toArray();\n    const center = bounds.getCenter().toArray();\n    const line = lineString([swCoordinate, center, neCoordinate]);\n    const distanceInMiles = length(line, { units: \"miles\" });\n    // Gets coordinates 1/4 along the line from each coordinate\n    const southWestCoordinate = along(line, distanceInMiles / 4, {\n        units: \"miles\",\n    }).geometry.coordinates;\n    const northeastCoordinate = along(line, distanceInMiles * (3 / 4), {\n        units: \"miles\",\n    }).geometry.coordinates;\n    // Creates a polygon from the coordinates found along the line between the bounding coordinates in counter clockwise order starting from northeast most coordinate\n    const polygon = [\n        [\n            northeastCoordinate,\n            [southWestCoordinate[0], northeastCoordinate[1]],\n            southWestCoordinate,\n            [northeastCoordinate[0], southWestCoordinate[1]],\n            northeastCoordinate,\n        ],\n    ];\n    return {\n        id,\n        type: \"Feature\",\n        geometry: {\n            type: \"Polygon\",\n            coordinates: polygon,\n        },\n        properties: {},\n    };\n};\nexport const getCircleFeatureFromCoords = (id, center, { bounds, radius }) => {\n    if (!bounds && !radius) {\n        throw new Error(\"Circle requires a bounds or a radius\");\n    }\n    validateCoordinates(center);\n    const circleRadius = radius !== null && radius !== void 0 ? radius : getDistanceFromBounds(bounds) / 8;\n    const circleFeature = circle(center, circleRadius, { units: \"miles\" });\n    return {\n        id,\n        type: \"Feature\",\n        properties: {\n            isCircle: true,\n            center,\n            radius: circleRadius,\n        },\n        geometry: {\n            type: \"Polygon\",\n            coordinates: circleFeature.geometry.coordinates,\n        },\n    };\n};\nconst getDistanceFromBounds = (bounds) => {\n    const swCoordinate = bounds.getSouthWest().toArray();\n    const neCoordinate = bounds.getNorthEast().toArray();\n    const center = bounds.getCenter().toArray();\n    const line = lineString([swCoordinate, center, neCoordinate]);\n    return length(line, { units: \"miles\" });\n};\nexport const doesGeofenceExist = (id, loadedGeofences) => {\n    return !!loadedGeofences[id];\n};\nexport const isValidGeofenceId = (id) => {\n    return !!id.match(GEOFENCE_ID_REGEX);\n};\nexport const isExistingGeofenceId = (id, loadedGeofences) => {\n    return doesGeofenceExist(id, loadedGeofences);\n};\nexport const isGeofenceDisplayed = (id, displayedGeofences) => {\n    return !!displayedGeofences.find((geofence) => geofence.geofenceId === id);\n};\nexport const getDistanceBetweenCoordinates = (startCoord, endCoord) => {\n    const line = lineString([startCoord, endCoord]);\n    const distanceInMiles = length(line, { units: \"miles\" });\n    return distanceInMiles;\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}